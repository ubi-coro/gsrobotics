""" 
calc_2d_cross_sections.py

Description:
	This script computes local cross-section areas along a deburred metal edge by sampling points on a 2D edge (x1,y1)→(x2,y2), generating a 3D “slab” of points in the corresponding point cloud, projecting them into a 2D plane, and fitting curves to estimate a chamfer area. Use this script to evaluate how a deburred edge transitions across its length and identify regions requiring further machining or refinement.
	
Core Functionality:
    Edge-Based Sampling:
        The script retrieves an edge location (e.g., from a results dict generated by "analyze_depthmap.py").
        It samples multiple points along that edge in 2D image coordinates.

    Slab Extraction & Projection:
        For each sampled point, a plane is defined (with a user-settable thickness factor).
        All 3D points from the cloud within ±thickness from the plane are collected (“slab”).
        These slab points are then projected into a local 2D coordinate system in the plane.

    Chamfer Filtering & Curve Fitting:
        A “chamfer line” is constructed in the 2D plane (based on angle info like beta_deg).
        Points lying below this chamfer line are filtered out, so only the “excess” region remains.
        The script fits either a spline or polynomial to the remaining 2D cross-section and numerically integrates the area between that curve and the chamfer line.

    Visualization (Optional):
        The user can enable debug plots, which display:
            The 3D slab region in the original point cloud (3D subplot).
            The 2D cross-section with fitted curves, chamfer lines, etc.

    Output:
        A final plot of local cross-section “areas” vs. sampled index along the edge, giving a quantitative measure of how much burr or material protrudes in each cross-section region.

Usage: 
	python cross_section_areas.py --index 0 --distance 6.0

	(where “--index” selects which part’s data to load—depth map, point cloud, and a results dictionary—and “--distance” controls the chamfer offset.)
	
Author/Contact:
    - Jannick Stranghöner (Universität Bielefeld, jannick.stranghoener@uni-bielefeld.de), 2024
    - (No warranties; adapted for demonstration of GelSight 3D capabilities)
"""
#!/usr/bin/env python3
import argparse
import pickle
import numpy as np
import open3d as o3d
import matplotlib.pyplot as plt

from scipy.interpolate import UnivariateSpline
from scipy.integrate import quad


def local_cross_section_areas(
        results_dict,
        depth_map,
        pcd,
        use_avg_depth=False,
        thickness_factor=1.0,
        num_steps=100,
        d_chamfer=5.0,
        approximation_method='polynomial',  # 'spline' or 'polynomial'
        spline_smoothing=10.0,
        poly_deg=6,
        enable_plot=True,
        num_steps_to_plot=1,
        num_steps_offset=None):
    """
    Compute local cross-section areas along an edge, by:
      1) Sampling points along a 2D edge (x1,y1)->(x2,y2),
      2) Defining a 3D plane around each sampled edge point,
      3) Projecting in-plane points,
      4) Filtering them by a 'chamfer' line in the 2D plane,
      5) Fitting a curve (spline or polynomial) for final area integration.

    Args:
      results_dict (dict): Contains 'edge_location' (x1,y1,x2,y2) and angles like 'beta_deg'.
      depth_map (ndarray): 2D array with depth values, shape [H,W].
      pcd (open3d.geometry.PointCloud): The 3D point cloud of the part.
      thickness_factor (float): Factor controlling how thick the plane “slab” is.
      num_steps (int): Number of points to sample along the edge in 2D.
      d_chamfer (float): Distance from the original edge to the chamfer.
      approximation_method (str): Either 'spline' or 'polynomial' for 1D fitting.
      spline_smoothing (float): Smoothing factor if using a UnivariateSpline.
      poly_deg (int): Polynomial degree if using a polynomial fit.
      enable_plot (bool): Whether to generate debug plots.
      num_steps_to_plot (int): Number of cross-sections to plot.
      num_steps_offset (None): Number of stepes after which to plot num_steps_to_plot planes, defaults to the center of the edge.

    Returns:
      indices (list[int]): The sampled index along the edge.
      areas (list[float]): The computed area at each sampled edge location.
    """

    # Convert the Open3D point cloud to a NumPy array
    pcd_points = np.asarray(pcd.points)

    # Determine bounding box for the entire point cloud
    xmin = np.min(pcd_points, axis=0)
    xmax = np.max(pcd_points, axis=0)

    # Load 2D edge location from results_dict
    (x1, y1, x2, y2) = results_dict['edge_location']

    # Create sampling in x and y over the edge
    xs = np.linspace(x1, x2, num_steps, dtype=int)
    ys = np.linspace(y1, y2, num_steps, dtype=int)

    # Edge vector in 2D
    edge_vec2d = np.array([x2 - x1, y2 - y1])
    # Decide thickness based on length of the edge, scaled by thickness_factor
    thickness = thickness_factor * np.linalg.norm(edge_vec2d) / num_steps

    if num_steps_offset is None:
        num_steps_offset = (num_steps - num_steps_to_plot) // 2

    areas = []
    indices = []
    num_plot_handles = 0

    # Loop through sampled points along the edge
    for i in range(len(xs)):
        xi = xs[i]
        yi = ys[i]

        if use_avg_depth and 'avg_depth' in results_dict:
            zi = results_dict['avg_depth']
        else:
            # Depth value from depth_map
            zi = depth_map[yi, xi]

        # The plane reference point in 3D
        pi = np.array([xi, yi, zi])

        # 3D plane normal definition
        # Option (a): incorporate local slope in z from the depth map
        # Option (b): use purely XY direction
        # Here we use (b): normal has no z-slope
        ni = np.array([edge_vec2d[0], edge_vec2d[1], 0.0])
        ni /= np.linalg.norm(ni)

        # 1) Compute the signed distance to the plane for each point in pcd_points
        # plane eqn: n·(x - pi) = 0
        diffs = pcd_points - pi
        dist_vals = np.einsum('ij,j->i', diffs, ni)

        # 2) Keep points within +/- "thickness" from that plane
        slab_mask = (np.abs(dist_vals) <= thickness)
        slab_points = pcd_points[slab_mask]
        if len(slab_points) < 3:
            areas.append(0.0)
            indices.append(i)
            continue

        # 3) Project these slab points onto the plane
        diffs_slab = slab_points - pi
        dot_slab = np.einsum('ij,j->i', diffs_slab, ni)
        x_proj = slab_points - np.outer(dot_slab, ni)

        # 4) Convert to 2D coords by defining plane basis (u_, v_)
        ref = np.array([1, 0, 0], dtype=float)
        # If ni is almost parallel to ref, pick a different ref
        if np.abs(np.dot(ref, ni)) > 0.99:
            ref = np.array([0, 1, 0], dtype=float)

        u_ = np.cross(ni, ref)
        u_ /= np.linalg.norm(u_)
        v_ = np.cross(ni, u_)

        # 2D coordinates => (v_vals, u_vals)
        u_vals = np.einsum('ij,j->i', x_proj, u_)
        v_vals = np.einsum('ij,j->i', x_proj, v_)

        # The 2D location of the plane reference point pi
        pi_uv = np.array([pi.dot(v_), pi.dot(u_)])

        # Combine into Nx2 array
        pts_2d = np.column_stack((v_vals, u_vals))

        # 5) Chamfer filtering:
        # Build a "bisector" from the dictionary's angle 'beta_deg'
        vec_bisector = np.array([1.0, np.tan(np.radians(results_dict['beta_deg']))])
        p_chamfer = pi_uv + d_chamfer * vec_bisector / np.linalg.norm(vec_bisector)
        # Slope of the chamfer line
        m_chamfer = -1.0 / np.tan(np.radians(results_dict['beta_deg']))
        vec_chamfer = np.array([1.0, m_chamfer])
        vec_chamfer /= np.linalg.norm(vec_chamfer)

        # Filter out points "below" the chamfer line
        pts_2d_filtered = np.array([
            _p for _p in pts_2d
            if _p[1] > p_chamfer[1] + (_p[0] - p_chamfer[0]) * m_chamfer
        ])

        # If not enough points remain, skip
        if len(pts_2d_filtered) < 3:
            areas.append(0.0)
            indices.append(i)
            continue

        # Sort them by the "v-axis" (here chosen as the first column, or whichever axis you want)
        pts_2d_sorted = pts_2d_filtered[pts_2d_filtered[:, 0].argsort()]
        u = pts_2d_sorted[:, 0]

        # 6) Build extended chamfer line for the local area
        p_chamfer_for_fit = pi_uv + 1.2 * d_chamfer * vec_bisector / np.linalg.norm(vec_bisector)
        pts_2d_filtered_for_fit = np.array([
            _p for _p in pts_2d
            if _p[1] > p_chamfer_for_fit[1] + (_p[0] - p_chamfer_for_fit[0]) * m_chamfer
        ])
        if len(pts_2d_filtered_for_fit) < 3:
            areas.append(0.0)
            indices.append(i)
            continue

        # x-axis is the first coordinate, y-axis is the second coordinate
        u_fit = pts_2d_filtered_for_fit[:, 0]
        v_fit = pts_2d_filtered_for_fit[:, 1]

        # Approximate the cross-section boundary using a polynomial or a spline
        if approximation_method == 'spline':
            approximator = UnivariateSpline(u_fit, v_fit, s=spline_smoothing)
        elif approximation_method == 'polynomial':
            # Build a polynomial fit
            coeffs = np.polyfit(u_fit, v_fit, deg=poly_deg)
            approximator = np.poly1d(coeffs)

        # Evaluate the function on a grid
        u_grid = np.linspace(u[0], u[-1], len(u))
        v_grid = approximator(u_grid)

        # Evaluate the chamfer line on the same grid
        chamfer_grid = p_chamfer[1] + (u_grid - p_chamfer[0]) * m_chamfer

        # 7) Integrate area = ∫[ (approximator(x) - chamfer_line(x)) dx ]
        def f_to_integrate(x):
            return approximator(x) - (p_chamfer[1] + (x - p_chamfer[0]) * m_chamfer)

        area, _ = quad(f_to_integrate, a=u[0], b=u[-1])
        areas.append(area)
        indices.append(i)
        print(f"Edge sample {i+1}/{num_steps}: Area = {area:.2f}")

        # PLOTTING / DEBUG VISUALIZATION
        if enable_plot and num_steps_offset <= i and num_plot_handles != num_steps_to_plot:
            # --- 3D Plot of relevant points ---
            fig = plt.figure(figsize=(12, 12))
            ax = fig.add_subplot(projection='3d')

            # Show the "slab" points in blue
            ax.scatter(slab_points[:, 0], slab_points[:, 1], slab_points[:, 2],
                       c='blue', s=35, label='Slab Points')

            # Show the projected points in green
            ax.scatter(x_proj[:, 0], x_proj[:, 1], x_proj[:, 2],
                       c='green', s=35, label='Projected Points')

            # Show the path of the edge itself in red
            x_e, y_e, z_e = [], [], []
            for j in range(len(xs)):
                x_e.append(xs[j])
                y_e.append(ys[j])
                z_e.append(depth_map[ys[j], xs[j]])
            ax.scatter(x_e, y_e, z_e, c='red', s=35, label='Edge Points')

            # Plot a subsampled set of the entire cloud in black
            ax.scatter(pcd_points[::25, 0], pcd_points[::25, 1],
                       pcd_points[::25, 2], c='k', s=3, label='Global Cloud')

            # Set bounding box
            ax.set_xlim([xmin[0], xmax[0]])
            ax.set_ylim([xmin[1], xmax[1]])
            ax.set_zlim([xmin[2], xmax[2]])

            ax.set_xlabel('X axis')
            ax.set_ylabel('Y axis')
            ax.set_zlabel('Z axis')
            ax.set_title(f"3D Slab and Projections (Step {i+1})")
            ax.legend()

            # --- 2D Plot in the plane coordinates ---
            plt.figure()
            plt.scatter(pi_uv[0], pi_uv[1], c='red', s=20, label='Reference Edge Pt')
            plt.scatter(p_chamfer[0], p_chamfer[1], c='green', s=20, label='Chamfer Start')
            plt.scatter(pts_2d[:,0], pts_2d[:,1], c='k', s=5, label='All Projected Pts')
            plt.plot(u_grid, v_grid, c='blue', label='Fitted Cross-Section')
            plt.plot(u_grid, chamfer_grid, c='green', label='Chamfer Line')

            plt.xlabel('u-axis in plane')
            plt.ylabel('v-axis in plane')
            plt.title(f"2D Cross-Section (Step {i+1})")
            plt.legend()
            plt.grid(True)

            # If we just want to show once up to num_steps_to_plot
            num_plot_handles += 1
            if num_plot_handles == num_steps_to_plot:
                plt.show()

    return indices, areas


def main():
    """
    Main entry point:
      1) Parse arguments
      2) Load data (point cloud, depth map, results dict)
      3) Call local_cross_section_areas to measure local cross-section areas
      4) Plot final area vs. edge index
    """
    parser = argparse.ArgumentParser(
        description="Compute local cross-section areas along a deburred edge."
    )
    parser.add_argument("-i", "--index", type=int, default=0,
                        help="Index for the results/depthmap/pcd naming.")
    parser.add_argument("-d", "--distance", type=float, default=6.0,
                        help="Distance from the original edge to the chamfer (d_chamfer).")
    args = parser.parse_args()

    # 1) Load the point cloud, depth map, and pickled corner parameters
    pcd_path = f'../captures/pc_{args.index}.pcd'
    depthmap_path = f'../captures/depthmap_{args.index}.npy'
    pickle_path = f'../results/results_{args.index}.pkl'

    print(f"Loading point cloud: {pcd_path}")
    pcd = o3d.io.read_point_cloud(pcd_path)

    print(f"Loading depth map: {depthmap_path}")
    depth_map = np.load(depthmap_path)

    print(f"Loading corner parameters: {pickle_path}")
    with open(pickle_path, 'rb') as f:
        results_dict = pickle.load(f)

    # 2) Run the local cross-section measurement
    indices, areas = local_cross_section_areas(
        results_dict=results_dict,
        depth_map=depth_map,
        pcd=pcd,
        d_chamfer=args.distance,
        enable_plot=True,          # show debug plots
        num_steps_to_plot=2        # how many cross-sections to plot in detail
    )

    # 3) Plot the final areas vs. the sampled edge index
    plt.figure()
    plt.plot(indices, areas, marker='o', linestyle='-', color='b')
    plt.xlabel('Phase / Index along Edge')
    plt.ylabel('Cross-Section Area')
    plt.title('Local Cross-Section Area vs. Edge Phase')
    plt.grid(True)
    plt.show()


if __name__ == "__main__":
    main()
